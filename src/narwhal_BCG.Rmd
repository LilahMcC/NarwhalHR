---
title: "narwhal_BCG"
author: "Lilah McCormick"
date: '2022-07-25'
output: html_document
---
```{r load}
library(tidyverse)
library(lubridate)
library(cetaceanbcg)
library(ggplot2)
source("src/util.R")
source("src/data.R")
```

```{r vars}
narwhal_id <- "asgeir"
win_s <- 2
acc_fs <- 100
upper <- 35
keep_phase <- c("descent")
by_criteria <- FALSE
```

```{r filter}
#reads motionless data from best periods into a dataframe with columns: time_start, time_end, and region_id 
ml_best <- function(narwhal_id){
  read_tsv(find_motionless(narwhal_id)) %>% 
  filter(meets_criteria == "Y") %>% 
  mutate(region_id = row_number()) %>% 
  select(-c(duration, narwhal_id, dive_phase, notes, meets_criteria)) %>% 
  arrange(time_start)
}

#ml_phase creates a df with 3 columns (time_start, time_end, and region_id) of  motionless periods, filtered by dive_phase.
#Parameters
#narwhal_id - narwhal identification in quotes. eg: "asgeir"
#keep_phase - a vector of character strings of dive phases to keep in the df. eg: c("bottom", "surface", "subsurface", "descent", "ascent")
ml_phase <- function(narwhal_id, keep_phase) {
  read_tsv(find_motionless(narwhal_id)) %>% 
    mutate(region_id = row_number()) %>% 
    filter(dive_phase %in% keep_phase) %>% #filter by dive phase 
    select(-c(duration, narwhal_id, meets_criteria, dive_phase, notes)) %>% #remove unneeded columns
    arrange(time_start) #%>% order chronologically
    #FIXME 
    # filter(region_id != 243) 
}
```

```{r ml_df}
if(by_criteria) {
  ml_filt <- ml_best(narwhal_id)
} else {
    ml_filt <- ml_phase(narwhal_id, keep_phase)
}
```

```{r narwhal_beats}
#narwhal_beats takes acceleration data, and applies all of the necessary filters, smoothers, and calculations, and returns a df with columns with each of these calculations. 
#Parameters: 
#ml_df - a dataframe with time_start, time_end, and region_id as columns 
#win_s - a number of seconds to calculate the moving averages. 
#acc_fs - frequency of acceleration data 
#upper - upper frequency cutoff, should increase with decreasing body size. 

narwhal_beats <- function(ml_df, win_s, acc_fs, upper, acc_narwhal) {
  
#should_retain returns a dataframe with a datetime col with all datetimes in acc data, and a column with T/F values. If a datetime in a particular row is found within a motionless period and its buffer, it will have TRUE under retain col for that row. 
#Parameters:
#dt - DateTime col of acceleration data
#motionless - motionless periods dataframe with time_start, time_end, and region_id columns
#buffer_s - number of seconds that should be added to the motionless period on either end
  # FIXME!!
  
  should_retain <- function(dt, motionless, buffer_s) { 
    retain <- logical(length(dt)) #retain is a column of T/F values 
    motionless <- filter(motionless, time_end < max(dt), time_start > min(dt))
    i_start <- as.numeric(motionless$time_start - buffer_s - dt[1],
                          unit = "secs") * acc_fs + 1
    i_end <- as.numeric(motionless$time_end + buffer_s - dt[1],
                        unit = "secs") * acc_fs + 1
    retain_idx <- map2(i_start, i_end, ~ .x:.y) %>% 
      unlist() %>% 
      pmin(length(dt)) %>% 
      pmax(1)
    retain[retain_idx] <- TRUE
    retain
  }
  
  acc_narwhal %>% 
    mutate(retain = should_retain(DateTime, ml_df, win_s + 0.1)) %>% 
    filter(retain) %>% 
    mutate(
      timestep = as.numeric(DateTime - lag(DateTime, default = DateTime[1] - acc_fs * 2), 
                            unit = "secs"),
      contiguous = abs(timestep - 1 / acc_fs) < 1e-4,
      contiguous_id = cumsum(!contiguous)
    ) %>% 
    group_by(contiguous_id) %>% 
    mutate(
      across(acc_x:acc_z, 
             filter_acc, fs = acc_fs, upper = upper, #applies bandwidth filter
             .names = "{.col}_filt"),
      jerk = jerk(cbind(acc_x_filt, acc_y_filt, acc_z_filt), #differencing
                  fs = acc_fs, p = 4, n = win_s * acc_fs + 1),
      jerk_se = shannon_entropy(jerk), #shannon entropy
      jerk_smooth = tma(jerk_se, win_s * acc_fs), #triangular moving average 
      # Annotate regions
      rid_left = approx(ml_df$time_start, 
                        ml_df$region_id, 
                        DateTime, 
                        "constant")$y,
      rid_right = approx(ml_df$time_end, 
                         ml_df$region_id, 
                         DateTime, 
                         "constant", 
                         yleft = 0)$y + 1,
      rid = ifelse(rid_left == rid_right, rid_left, NA),
      # Zero-out signal in non-valid regions (i.e. remove movement artifacts)
      jerk_smooth = ifelse(is.na(rid), 0, jerk_smooth)
    ) %>% 
    ungroup()
}
narwhal_acc <- read_acc(narwhal_id)
narwhal_100hz <- narwhal_beats(ml_filt,
                               win_s,
                               acc_fs,
                               upper,
                               narwhal_acc) #should rid = NA in some cases?
```

```{r}
bcg3d_psd <- with(narwhal_100hz, pspectrum(jerk_smooth[!is.na(rid)], 100)) 

psd_df <- tibble(
  freq_hz = bcg3d_psd$freq,
  spec = bcg3d_psd$spec
) %>% 
  mutate(freq_bpm = freq_hz * 60) %>% 
  filter(freq_bpm <= 50)

signal_rng <- c(10, 20)

signal_df <- filter(psd_df, between(freq_bpm, signal_rng[1], signal_rng[2]))

psd_s2n <- psd_df %>% 
  summarize(signal = pracma::trapz(freq_bpm[freq_bpm >= signal_rng[1] & freq_bpm <= signal_rng[2]],
                                   spec[freq_bpm >= signal_rng[1] & freq_bpm <= signal_rng[2]]),
            noise = pracma::trapz(freq_bpm, spec) - signal) %>% 
  mutate(s2n = signal / noise)

ggplot(psd_df, aes(x = freq_bpm, y = spec)) +
  geom_area(data = signal_df, fill = "grey80") +
  geom_path() +
  annotate("text", 
           x = mean(signal_rng), 
           y = max(signal_df$spec) * 1.1, 
           label = sprintf("S2N=%0.3f", psd_s2n$s2n)) +
  labs(x = "Frequency (bpm)",
       y = "Power spectral density") +
  theme_classic()
```


```{r calc_s2n}
#calc_s2n takes in a dataframe (eg. narwhal_100hz), and returns the signal to noise ratio for jerk_smooth for that df, using a signal range of 10 - 20 bpm. 
#Parameters: 
#df - a dataframe with columns jerk_smooth and rid. 
#verbose - boolean. If TRUE, will return a list with items psd_df, and s2n. If false, will return just s2n. 

calc_s2n <- function(df, verbose = FALSE) {
  
  bcg3d_psd <- with(df, pspectrum(jerk_smooth[!is.na(rid)], 100))  #i think this takes narwhal_100hz, and returns a bunch of values associated with psd. It excludes any rows were rid = NA. Specifies that sampling freq is 100 hz. 
  
  psd_df <- tibble( #creates a df with 1 column of frequencies, and another with spec(?) corresponding to those frequencies
    freq_hz = bcg3d_psd$freq, 
    spec = bcg3d_psd$spec
  ) %>% 
    mutate(freq_bpm = freq_hz * 60) %>% #adds a 3rd column freq_bpm, which is the frequencies in freq_hz in units of bpm 
    filter(freq_bpm <= 50) #removes any rows where freq_bpm > 50 bpm, since this is outside the expected range of a narwhal hr. 
  
  
  signal_rng <- c(10, 20) #creates a vector with boundary values considered "signal"
  
  signal_df <- filter(psd_df, between(freq_bpm, signal_rng[1], signal_rng[2])) #creates a new df with same cols and values from psd_df, but only includes rows in which freq_bpm is between 10 and 20 bpm. 
  
  psd_s2n <- psd_df %>% # creates a df with 3 columns: signal,  noise, and s2n (signal-to-noise-ratio) Values for s2n should be at least > 1. 
    summarize(signal = pracma::trapz(freq_bpm[freq_bpm >= signal_rng[1] & freq_bpm <= signal_rng[2]],
                                     spec[freq_bpm >= signal_rng[1] & freq_bpm <= signal_rng[2]]), #calc signal 
              noise = pracma::trapz(freq_bpm, spec) - signal) %>% # calc noise
    mutate(s2n = signal/noise) #add s2n col 
  
  if(verbose) {
    list(
      psd_df = psd_df, 
      s2n = psd_s2n$s2n
    )
  } else {
    psd_s2n$s2n
  }
}
```


```{r}
#returns a the s2n ratio for window size, upper limit, and dive phase combination.
#Parameters 
#win_size - for all windowed operations (a number)
#upper limit - a number
#dive phase - a charater string with col name of dive phase. 
#narwhal_acc - df with acc x, y, z, and DateTime
#plots - boolean, when TRUE, creates a saves a plot of psd for each dive_phase, win_size, upper combination

quality_check <- function(win_size, upper, dive_phase, narwhal_acc, plots = TRUE) {
  motionless <- ml_phase(narwhal_id, dive_phase)
  narwhal_s2n <- narwhal_beats(motionless, win_size, acc_fs = 100, upper, narwhal_acc) %>%
    calc_s2n(verbose = plots)
  
  if(plots) {
    # use narwhal_s2n$psd_df to create and save the figure
    plot_path <- file.path("figures", "s2n", glue::glue("{narwhal_id}_{dive_phase}_{win_size}_{upper}.jpeg"))
    cat(plot_path)
    signal_rng <- c(10, 20) #creates a vector with boundary values considered "signal"
    signal_df <- filter(narwhal_s2n$psd_df, between(freq_bpm, signal_rng[1], signal_rng[2]))
    
    s2n_plot <- ggplot(narwhal_s2n$psd_df,
                       aes(x = freq_bpm, y = spec)) +
      geom_area(data = signal_df, fill = "grey80") +
      geom_path() +
      annotate("text", 
               x = mean(signal_rng), 
               y = max(signal_df$spec) * 1.1, 
               label = sprintf("S2N=%0.3f", narwhal_s2n$s2n)) +
      labs(x = "Frequency (bpm)",
           y = "Power spectral density") +
      theme_classic()
    
    ggsave(plot_path, s2n_plot,device="jpeg")
    
    narwhal_s2n$s2n
  } else {
    narwhal_s2n
  }
}

win_sizes <- c(0.5, 1.0, 1.5, 2.0)
uppers <- c(10, 15, 20, 25)
phases <- c("descent", "bottom", "subsurface")
dive_phase <- map(seq_along(phases), 
                  ~ combn(phases, .x, simplify = FALSE)) %>% 
  unlist(recursive = FALSE)
s2ns <- expand_grid(
  win_size = win_sizes[1],
  upper = uppers[1], 
  dive_phase
) %>% 
  mutate(s2n = pmap_dbl(.,
                        quality_check, 
                        narwhal_acc))
```

```{r waveform_plot}
#FIXME
narwhal_100hz_new <- narwhal_100hz %>% 
  filter(rid == 2) %>% #select 1 ml period 
  subset(select = -c(retain, timestep, contiguous, contiguous_id, rid, rid_left, rid_right)) %>% 
  pivot_longer(!DateTime, names_to = "wave_type", values_to = "value")

  narwhal_100hz_new <- pivot_longer(narwhal_100hz_new, cols = value[,1]:value[,3], names_to = "wave_type", values_to = "value") #having trouble getting this to pivot_longer
  
waveform_plot <- ggplot(narwhal_100hz_new, aes(x = "DateTime", y = "jerk_se")) + 
  geom_line()

waveform_plot

```

```{r s2ns_plot}
s2n_df <- filter(readRDS("data/derived_data/asgeir_s2ns.rds"), dive_phase == "descent")
s2ns_plot <- ggplot(s2n_df, aes(x = upper, y = s2n, color = factor(win_size), group = win_size)) + 
  geom_line(size = 1) +
  geom_point(size = 3) + 
  theme(rect = element_blank()) +
  labs(x = "upper cutoff frequency", 
       y = "signal / noise", 
       color = "window size") +
  guides(color = guide_legend(override.aes = list(shape = 16))) + #this line isn't working 
  scale_color_brewer(palette = "Paired")

s2ns_plot
```

